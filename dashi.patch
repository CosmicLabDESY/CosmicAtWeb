Index: src/dashi/histogram.py
===================================================================
--- src/dashi/histogram.py	(revision 287)
+++ src/dashi/histogram.py	(working copy)
@@ -3,6 +3,7 @@
 import logging
 from logging import getLogger
 import fitting, histfuncs
+from collections import OrderedDict
 
 
 class histogram_statistics(object):
@@ -12,25 +13,26 @@
     """
 
     def __init__(self, histogram):
-        self.values = dict()
+        self.values = OrderedDict()
         self.histogram = histogram # keep a reference to the histogram
         self.clear()
 
     def clear(self):
         " set all counters to zero "
-        self.weights_used = False
-
-        zerovalue = 0 if self.histogram.ndim == 1 else (0,) * self.histogram.ndim
-        self.values["nentries"]  = 0
-        self.values["mean"]      = zerovalue
-        self.values["var"]       = zerovalue
-        self.values["std"]       = zerovalue
-        self.values["median"]    = zerovalue
-        self.values["ske"]       = zerovalue
-        self.values["kur"]       = zerovalue
-        self.values["exc"]       = zerovalue
-        self.values["underflow"]    = zerovalue
-        self.values["overflow"]    = zerovalue
+        initvalue = n.nan if self.histogram.ndim == 1 else (n.nan,) * self.histogram.ndim
+        self.values["nentries"] = 0
+        self.values["weightsum"] = n.nan
+        self.values["integral"] = n.nan
+        self.values["neffective"] = n.nan
+        self.values["mean"] = initvalue
+        self.values["var"] = initvalue
+        self.values["std"] = initvalue
+        self.values["median"] = initvalue
+        self.values["ske"] = initvalue
+        self.values["kur"] = initvalue
+        self.values["exc"] = initvalue
+        self.values["underflow"] = initvalue
+        self.values["overflow"] = initvalue
 
     def __get_stats(self, varname):
         """
@@ -41,69 +43,82 @@
             self.calc_stats()
         return self.values[varname]
 
-    weightsum  = property(lambda self: self.histogram.bincontent.sum())
-    neffective = property(lambda self :  ( self.weightsum**2 )  / ( self.histogram.squaredweights.sum()**2 ))
-    nentries   = property(lambda self : self.__get_stats("nentries") )
-    mean       = property(lambda self : self.__get_stats("mean") )
-    var        = property(lambda self : self.__get_stats("var") )
-    std        = property(lambda self : self.__get_stats("std") )
-    median     = property(lambda self : self.__get_stats("median") )
-    skewness   = property(lambda self : self.__get_stats("ske"))
-    kurtosis   = property(lambda self : self.__get_stats("kur"))
-    excess     = property(lambda self : self.__get_stats("exc"))
-    underflow  = property(lambda self : self.__get_stats("underflow") )
-    overflow   = property(lambda self : self.__get_stats("overflow") )
+    nentries = property(lambda self : self.__get_stats("nentries"))
+    weightsum = property(lambda self : self.__get_stats("weightsum"))
+    integral = property(lambda self : self.__get_stats("integral"))
+    neffective = property(lambda self : self.__get_stats("neffective"))
+    minimum = property(lambda self : self.__get_stats("min"))
+    maximum = property(lambda self : self.__get_stats("max"))
+    mean = property(lambda self : self.__get_stats("mean"))
+    var = property(lambda self : self.__get_stats("var"))
+    std = property(lambda self : self.__get_stats("std"))
+    median = property(lambda self : self.__get_stats("median"))
+    skewness = property(lambda self : self.__get_stats("ske"))
+    kurtosis = property(lambda self : self.__get_stats("kur"))
+    excess = property(lambda self : self.__get_stats("exc"))
+    underflow = property(lambda self : self.__get_stats("underflow"))
+    overflow = property(lambda self : self.__get_stats("overflow"))
 
 
     def calc_stats(self):
         """
             calculate statistics and set _h_newdataavailable to false
         """
+
         if self.histogram.ndim == 1:
             wsum = self.histogram.bincontent.sum()
             mean = (self.histogram.bincontent * self.histogram._h_bincenters[0]).sum() / wsum
             meansquared = (self.histogram.bincontent * self.histogram._h_bincenters[0]**2).sum() / wsum
-            var = meansquared - mean**2
-            std =  n.sqrt( var )
-            medianindex = (self.histogram.bincontent.cumsum() / wsum).searchsorted(0.5, side="right")
-            median =  self.histogram._h_bincenters[0][medianindex]
+            var = meansquared - mean ** 2
+            std = n.sqrt(var)
+            medianindex = (self.histogram.bincontent.cumsum() / wsum).searchsorted(0.5, side = "right")
+            median = self.histogram._h_bincenters[0][medianindex]
             meancubed = (self.histogram.bincontent * self.histogram._h_bincenters[0]**3).sum() / wsum
-            skewness = (meancubed - 3*mean*var - mean**3)/ (var ** (3./2.))
+            skewness = (meancubed - 3 * mean * var - mean ** 3) / (var ** (3. / 2.))
             meanpow4 = (self.histogram.bincontent * self.histogram._h_bincenters[0]**4).sum() / wsum
-            kurtosis = (meanpow4 - 4*mean*meancubed+ 6*(mean**2)*meansquared - 4*(mean**4) + mean**4) / (var ** 2)
-            excess = kurtosis - 3 
+            kurtosis = (meanpow4 - 4 * mean * meancubed + 6 * (mean ** 2) * meansquared - 4 * (mean ** 4) + mean ** 4) / (var ** 2)
+            excess = kurtosis - 3
+            self.values["integral"] = (self.histogram.bincontent * self.histogram.binwidths).sum()
+            self.values["weightsum"] = wsum
+            self.values["neffective"] = (wsum ** 2) / (self.histogram.squaredweights.sum() ** 2)
             self.values["mean"] = mean
-            self.values["var"]  = var
-            self.values["std"]  = std
-            self.values["median"]  = median
-            self.values["ske"]  = skewness
-            self.values["kur"]  = kurtosis
-            self.values["exc"]  = excess
+            self.values["var"] = var
+            self.values["std"] = std
+            self.values["median"] = median
+            self.values["ske"] = skewness
+            self.values["kur"] = kurtosis
+            self.values["exc"] = excess
             self.values["underflow"] = self.histogram._h_bincontent[0]
-            self.values["overflow"]  = self.histogram._h_bincontent[-1]
+            self.values["overflow"] = self.histogram._h_bincontent[-1]
         else:
-            means, vars, stds, medians,uflows, oflows   = [],[],[],[],[],[]
+            means, vars, stds, medians, uflows, oflows = [], [], [], [], [], []
 
             for dim in xrange(self.histogram.ndim):
                 tmp = histfuncs.project_bincontent(self.histogram, dim)
                 wsum = tmp.sum() # == self.histogram.bincontent.sum() == sum of weights
-                mean        = (tmp * self.histogram._h_bincenters[dim]   ).sum() / wsum
+                mean = (tmp * self.histogram._h_bincenters[dim]).sum() / wsum
                 meansquared = (tmp * self.histogram._h_bincenters[dim]**2).sum() / wsum
-                var = meansquared - mean**2 
-                medianindex = (tmp.cumsum() / wsum).searchsorted(0.5, side="right")
-                median =  self.histogram._h_bincenters[dim][medianindex] 
-                
+                var = meansquared - mean ** 2
+                medianindex = (tmp.cumsum() / wsum).searchsorted(0.5, side = "right")
+                median = self.histogram._h_bincenters[dim][medianindex]
+
                 means.append(mean)
                 vars.append(var)
-                stds.append( n.sqrt(var) )
-                medians.append( median)
+                stds.append(n.sqrt(var))
+                medians.append(median)
                 # FIXME find a good representation for these
-                uflows.append( n.nan )
-                oflows.append( n.nan )
-            
-            self.values["mean"]   = tuple(means)
-            self.values["var"]    = tuple(vars)
-            self.values["std"]    = tuple(stds)
+                uflows.append(n.nan)
+                oflows.append(n.nan)
+
+            bincontents = self.histogram.bincontent
+            self.values["weightsum"] = wsum = self.histogram.bincontent.sum()
+            xbinwidths = self.histogram.xbinwidths.reshape((len(self.histogram.xbinwidths), 1))
+            ybinwidths = self.histogram.ybinwidths.reshape((1, len(self.histogram.ybinwidths)))
+            self.values["integral"] = ((xbinwidths * ybinwidths) * bincontents).sum()
+            self.values["neffective"] = (wsum ** 2) / (self.histogram.squaredweights.sum() ** 2)
+            self.values["mean"] = tuple(means)
+            self.values["var"] = tuple(vars)
+            self.values["std"] = tuple(stds)
             self.values["median"] = tuple(medians)
             self.values["underflow"] = tuple(uflows)
             self.values["overflow"] = tuple(oflows)
@@ -119,12 +134,12 @@
         This is the generic base class for :class:`~dashi.histogram.hist1d` and :class:`~dashi.histogram.hist2d`
     """
 
-    _h_binwidths  = property(lambda self : [ (edges[2:-1] - edges[1:-2]) for edges in self._h_binedges],
-                             doc="a list of arrays containing the widths of all bins")
-    _h_bincenters = property(lambda self : [ 0.5*(edges[2:-1] + edges[1:-2]) for edges in self._h_binedges],
-                             doc="a list of arrays containing the centers of all bins")
-    
-    def __init__(self, ndim, binedges, labels=None, title=None):
+    _h_binwidths = property(lambda self : [ (edges[2:-1] - edges[1:-2]) for edges in self._h_binedges],
+                             doc = "a list of arrays containing the widths of all bins")
+    _h_bincenters = property(lambda self : [ 0.5 * (edges[2:-1] + edges[1:-2]) for edges in self._h_binedges],
+                             doc = "a list of arrays containing the centers of all bins")
+
+    def __init__(self, ndim, binedges, labels = None, title = None):
         """
             Constructor for an empty n-dimensional histogram. The module 
             :module:`dashi.histfactory` provides convenient factory methods.
@@ -142,17 +157,17 @@
 
         assert len(binedges) == ndim
         self.ndim = ndim
-       
+
         # lists containing for every dimension the binedges, -centers and -widths
-        self._h_binedges   = []
+        self._h_binedges = []
 
         # these will be n-dimensional  datacubes holding the bincontent and the squared weights
         self._h_bincontent = None
         self._h_squaredweights = None
 
         # each histogram holds a reference to a statistics object
-        self.stats = histogram_statistics(self)  
-        
+        self.stats = histogram_statistics(self)
+
         # store a string for every dimension. can be used to label plots
         if labels is not None:
             assert (len(labels) == ndim)
@@ -176,24 +191,24 @@
             # len(binedges) = len(centers|widths) +2 (overflow) + 1 (edge vs. bin)
             assert len(self._h_binedges[-1]) - 3 == len(self._h_bincenters[-1])
             assert len(self._h_bincenters[-1]) == len(self._h_binwidths[-1])
-        
+
         # create the histogram arrays (n-dimensional datacubes)
         # these internal arrays have overflow bins
-        datacubeshape = [len(i)-1 for i in self._h_binedges]
-        self._h_bincontent     = n.zeros(datacubeshape, dtype=float)
-        self._h_squaredweights = n.zeros(datacubeshape, dtype=float)
+        datacubeshape = [len(i) - 1 for i in self._h_binedges]
+        self._h_bincontent = n.zeros(datacubeshape, dtype = float)
+        self._h_squaredweights = n.zeros(datacubeshape, dtype = float)
 
         # present views of the non overflow bins to the outside 
-        self._h_visiblerange = [slice(1,-1) for i in xrange(self.ndim)]
-        self.bincontent      = self._h_bincontent[self._h_visiblerange]
-        self.squaredweights  = self._h_squaredweights[self._h_visiblerange]
-        self.nbins           = tuple([i-2 for i in self._h_bincontent.shape])
+        self._h_visiblerange = [slice(1, -1) for i in xrange(self.ndim)]
+        self.bincontent = self._h_bincontent[self._h_visiblerange]
+        self.squaredweights = self._h_squaredweights[self._h_visiblerange]
+        self.nbins = tuple([i - 2 for i in self._h_bincontent.shape])
 
         self._h_newdataavailable = True # internal trigger for the recalculation of dervived values (e.g. errors, stats,..)
 
 
 
-    def fill(self, sample, weights=None):
+    def fill(self, sample, weights = None):
         """
             fill values from sample into the histogram
             
@@ -207,16 +222,19 @@
                     the histogram. The lengths of the sample and weights array must be
                     compatible.
         """
+        if len(sample) == 0:
+            return
 
         if isinstance(sample, tuple):
             if len(sample) != self.ndim:
                 raise ValueError("given tuple must have lenght of ndim=%d" % self.ndim)
             if not all([hasattr(i, "__len__") for i in sample]):
                 raise ValueError("given tuple doesn't contain iterable items")
-            if not len( n.unique([len(i) for i in sample])) == 1:
+            if not len(n.unique([len(i) for i in sample])) == 1:
                 raise ValueError("given tuple contains unequal sized arrays")
 
             sample = n.vstack(sample).T
+
         elif isinstance(sample, n.ndarray):
             if len(sample.shape) == 1:
                 if self.ndim > 1:
@@ -227,47 +245,45 @@
                 if not sample.shape[1] == self.ndim:
                     raise ValueError("shape mismatch. provided sample should have dimensions (len, ndim=%d)" % self.ndim)
 
-        if not len(sample) >= 1:
-            return
 
         # catch nans ...
         if weights != None:
             self.stats.weights_used = True
             assert len(weights) == len(sample)
             if n.isnan(weights).any():
-                raise ValueError("given weights contain nans!")
+                raise ValueError("weights must not contain nans!")
 
-        nanmask = n.ones(len(sample), dtype=bool)
+        nanmask = n.ones(len(sample), dtype = bool)
         for dim in xrange(self.ndim):
-            nanmask &= n.isnan(sample[:,dim])
+            nanmask &= n.isnan(sample[:, dim])
 
-        nnans = len(nanmask[nanmask])
+        nnans = nanmask.sum()
 
         if nnans > 0:
-            if weights==None:
+            if weights == None:
                 getLogger("dashi.histogram").warn("The sample contains %d nan values, which are omitted in the histogram." % nnans)
             else:
-                getLogger("dashi.histogram").warn("The sample contains %d nan values with a total weight of %f, which are omitted" % 
+                getLogger("dashi.histogram").warn("The sample contains %d nan values with a total weight of %f, which are omitted" %
                                   (nnans, weights[nanmask].sum()))
-        
-            goodmask = n.logical_not(nanmask)
+
+            nanmask = n.logical_not(nanmask)
 
             # ... and get rid of them
-            sample = sample[goodmask]
+            sample = sample[nanmask]
             if weights != None:
-                weights = weights[goodmask]
+                weights = weights[nanmask]
 
         self._h_newdataavailable = True
 
         if len(sample) > 0:
             # call numpy histogramdd to get the bincontents and add it to the local bincontent array
-            histnd, edges = n.histogramdd(sample,bins=self._h_binedges, weights=weights)
+            histnd, edges = n.histogramdd(sample, bins = self._h_binedges, weights = weights)
             self._h_bincontent += histnd
             self.stats.values["nentries"] += len(sample)
             if weights == None:
                 self._h_squaredweights += histnd
             else:
-                histnd, edges = n.histogramdd(sample,bins=self._h_binedges,weights=n.power(weights,2))
+                histnd, edges = n.histogramdd(sample, bins = self._h_binedges, weights = n.power(weights, 2))
                 self._h_squaredweights += histnd
         else:
             getLogger("dashi.histogram").warn("Only nans of infinites were passed to fill!")
@@ -276,7 +292,7 @@
         """
             Sets all counters back to zero.
         """
-        self._h_bincontent.fill(0)    
+        self._h_bincontent.fill(0)
         self._h_squaredweights.fill(0)
         self.stats.clear()
 
@@ -293,7 +309,7 @@
             checks for the correct dimensionality and the exact
             same binning.
         """
-        try:   
+        try:
             assert (type(self) == type(other))
             assert (self.ndim == other.ndim)
             for i in xrange(self.ndim):
@@ -317,45 +333,42 @@
 
         return newhist
 
-    def __radd__(self,other):
+    def __radd__(self, other):
         return self.__add__(other)
 
     def __iadd__(self, other):
         "implement histogram += histogram"
         if not self.is_compatible(other):
             raise ValueError("histograms are not compatible")
-        
-        self._h_bincontent     += other._h_bincontent
+
+        self._h_bincontent += other._h_bincontent
         self._h_squaredweights += other._h_squaredweights
         self._h_newdataavailable = True
         self.stats.values["nentries"] += other.stats.values["nentries"]
 
         return self
-    
+
     def __sub__(self, other):
         raise NotImplementedError()
-    
+
     def __imul__(self, other):
         "implement histogram *= scalar"
         if not n.isscalar(other):
             raise ValueError("multiplication is only implemented for scalars")
-        
+
         self._h_bincontent *= float(other)
-        self._h_squaredweights *= float(other)**2
+        self._h_squaredweights *= float(other) ** 2
         self._h_newdataavailable = True
         return self
-    
+
     def __mul__(self, other):
         "implement histogram * scalar"
-        if not n.isscalar(other):
-            raise ValueError("division is only implemented for scalars")
-        
         newhist = self.empty_like()
         newhist += self
         newhist *= other
         return newhist
-    
-    def __rmul__(self,other):
+
+    def __rmul__(self, other):
         "implement scalar * histogram"
         return self.__mul__(other)
 
@@ -363,17 +376,17 @@
         "implement histogram /= scalar"
         if not n.isscalar(other):
             raise ValueError("division is only implemented for scalars")
-        
+
         if other != 0:
-            self *= ( 1. / float(other) )
+            self *= (1. / float(other))
         return self
-    
+
     def __div__(self, other):
         "implement histogram / scalar"
         if not n.isscalar(other):
             raise ValueError("division is only implemented for scalars")
         if other != 0:
-            return (self * ( 1. / float(other) ) )
+            return (self * (1. / float(other)))
         else:
             return self
 
@@ -382,20 +395,20 @@
     """
         one dimensional specialization for :class:`dashi.histogram.histogram`
     """
-    def __init__(self, binedges, label=None, title=None):
-        if label is not None:
+    def __init__(self, binedges, label = None, title = None):
+        if label:
             label = (label,)
-        histogram.__init__(self, 1, (binedges,), labels=label, title=title)
+        histogram.__init__(self, 1, (binedges,), labels = label, title = title)
 
-    binedges   = property(lambda self : self._h_binedges[0][1:-1], None)
+    binedges = property(lambda self : self._h_binedges[0][1:-1], None)
     bincenters = property(lambda self : self._h_bincenters[0], None)
-    binwidths  = property(lambda self : self._h_binwidths[0])
-    xerr       = property(lambda self : self._h_binwidths[0]/2.)
-    binerror   = property(lambda self : n.sqrt(self._h_squaredweights[1:-1]), None)
-    
+    binwidths = property(lambda self : self._h_binwidths[0])
+    xerr = property(lambda self : self._h_binwidths[0] / 2.)
+    binerror = property(lambda self : n.sqrt(self._h_squaredweights[1:-1]), None)
+
     #underflow  = property(lambda self : self._h_bincontent[0], None) 
     #overflow   = property(lambda self : self._h_bincontent[-1], None) 
-    
+
     def empty_like(self):
         return hist1d(self._h_binedges[0].copy(), self.labels[0], self.title)
 
@@ -409,51 +422,51 @@
                 raise ValueError("range must be a tuple of length 2!")
         # remove empty bins from fit
         if mask is not None:
-            x = n.compress(self.bincontent[mask], self.bincenters[mask]) 
-            y = n.compress(self.bincontent[mask], self.bincontent[mask]) 
-            error = n.compress(self.bincontent[mask], self.binerror[mask]) 
-        else:    
-            x = n.compress(self.bincontent, self.bincenters) 
-            y = n.compress(self.bincontent, self.bincontent) 
-            error = n.compress(self.bincontent, self.binerror) 
+            x = n.compress(self.bincontent[mask], self.bincenters[mask])
+            y = n.compress(self.bincontent[mask], self.bincontent[mask])
+            error = n.compress(self.bincontent[mask], self.binerror[mask])
+        else:
+            x = n.compress(self.bincontent, self.bincenters)
+            y = n.compress(self.bincontent, self.bincontent)
+            error = n.compress(self.bincontent, self.binerror)
 
-        return x,y,error
+        return x, y, error
 
 
-    def leastsq(self, model, range=None, **kwargs):
+    def leastsq(self, model, range = None, **kwargs):
         """
             fit of model to bincontent by minimizing chi^2
         """
 
-        x,y,error = self.__select_fit_bins(range)
-        return fitting.leastsq(x,y,model,error,**kwargs)
-    
-    def poissonllh(self, model, range=None, verbose=True):
+        x, y, error = self.__select_fit_bins(range)
+        return fitting.leastsq(x, y, model, error, **kwargs)
+
+    def poissonllh(self, model, range = None, verbose = True):
         """
             fit of model to bincontent by minimizing a Poisson log likelihood
         """
 
-        x,y,error = self.__select_fit_bins(range)
-        return fitting.poissonllh(x,y,model,error,verbose)
+        x, y, error = self.__select_fit_bins(range)
+        return fitting.poissonllh(x, y, model, error, verbose)
 
 
-    def normalized(self, norm=1., density=False):
+    def normalized(self, norm = 1., density = False):
+        normalized_hist = self * (norm / self.bincontent.sum())
         if density:
-            return self / (norm* ((self.bincontent*self.binwidths).sum()))
-        else:
-            return self / (norm*self.stats.weightsum)
+            normalized_hist.bincontent /= self.binwidths
+            normalized_hist.squaredweights /= self.binwidths ** 2
+        return normalized_hist
 
-    
 
-    def rebin(self, bins_to_merge=2):
+    def rebin(self, bins_to_merge = 2):
             """ rebins the histogram (was tried to be written by Arne, so don't blame Eike!)
             gives back new rebinned histogram (old one is not overwritten)
             if number of bins is not a multiple of number, excess bins are thrown in the overflow bin 
             
             bins_to_merge: number of bins to merge to new bin (standard value = 2)"""
-            
-            print "Number of bins to merge to a one new bin = ", bins_to_merge        
-            return histfuncs.Rebin(self, bins_to_merge)          
+
+            print "Number of bins to merge to a one new bin = ", bins_to_merge
+            return histfuncs.Rebin(self, bins_to_merge)
 
     @property
     def func(self):
@@ -464,33 +477,39 @@
             if x < self.binedges[0] or self.binedges[-1] < x:
                 return 0.
             else:
-                for i,(bin_min,bin_max) in enumerate(zip(self.binedges[:-1], self.binedges[1:])):
-                    if (bin_min <= x) and (x<bin_max):
+                for i, (bin_min, bin_max) in enumerate(zip(self.binedges[:-1], self.binedges[1:])):
+                    if (bin_min <= x) and (x < bin_max):
                         return self.bincontent[i]
         return n.vectorize(method)
-            
+
 
 
 class hist2d(histogram):
     """
         two dimensional specialization for :class:`dashi.histogram.histogram`
     """
-    def __init__(self, binedges, labels=None, title=None):
+    def __init__(self, binedges, labels = None, title = None):
         histogram.__init__(self, 2, binedges, labels, title)
-    
-    binedges   = property(lambda self : [i[1:-1] for i in self._h_binedges], None)
+
+    binedges = property(lambda self : [i[1:-1] for i in self._h_binedges], None)
     bincenters = property(lambda self : self._h_bincenters, None)
-    xerr       = property(lambda self : self._h_binwidths[0]/2.)
-    yerr       = property(lambda self : self._h_binwidths[1]/2.)
-    binerror   = property(lambda self : n.sqrt(self._h_squaredweights[self._h_visiblerange]), None)
-    
+    xbinwidths = property(lambda self : self._h_binwidths[0])
+    xerr = property(lambda self : self._h_binwidths[0] / 2.)
+    ybinwidths = property(lambda self : self._h_binwidths[1])
+    yerr = property(lambda self : self._h_binwidths[1] / 2.)
+    binerror = property(lambda self : n.sqrt(self._h_squaredweights[self._h_visiblerange]), None)
+
     def empty_like(self):
         return hist2d(self._h_binedges, self.labels, self.title)
 
-    
-    def normalized(self, norm=1., density=False):
-        # please check formula for density!
+
+    def normalized(self, norm = 1., density = False):
+        bincontents = self.bincontent
+        normalized_hist = self * (norm / bincontents.sum())
         if density:
-            return self / ( norm* ( ((self.bincontent*self._h_binwidths[1]).transpose()*self._h_binwidths[0]).sum() )  ) 
-        else:
-            return self / (norm*self.stats.weightsum)
+            xbinwidths = self.xbinwidths.reshape((len(self.xbinwidths), 1))
+            ybinwidths = self.ybinwidths.reshape((1, len(self.ybinwidths)))
+            binareas = xbinwidths * ybinwidths
+            normalized_hist.bincontent /= binareas
+            normalized_hist.squaredweights /= binareas ** 2
+        return normalized_hist
Index: src/dashi/histfactory.py
===================================================================
--- src/dashi/histfactory.py	(revision 287)
+++ src/dashi/histfactory.py	(working copy)
@@ -8,7 +8,7 @@
 import numpy as n
 
 
-def hist1d(sample, bins, weights=None, label=None, title=None):
+def hist1d(sample, bins, weights = None, label = None, title = None):
     """
         factory method to create one dimensional histograms
 
@@ -37,13 +37,13 @@
             the filled :class:`dashi.histogram.hist1d`
                 
     """
-    
+
     if not isinstance(sample, n.ndarray):
         sample = n.asarray(sample)
 
     if (not weights is None) and (not isinstance(weights, n.ndarray)):
         weights = n.asarray(weights)
-    
+
     if not isinstance(bins, n.ndarray):
         if isinstance(bins, tuple):
             bins = histfuncs.generatebins_1d_tuple(bins)
@@ -56,7 +56,7 @@
     return h
 
 
-def hist2d(sample, bins, weights=None, labels=None, title=None):
+def hist2d(sample, bins, weights = None, labels = None, title = None):
     """
         factory method to create two dimensional histograms
 
@@ -85,14 +85,14 @@
     """
     if not (isinstance(bins, tuple) and all(map(lambda i: isinstance(i, n.ndarray), bins))):
         bins = histfuncs.generatebins_nd(2, sample, bins)
-    
+
     if isinstance(sample, tuple) and (all(map(lambda i: isinstance(i, list), sample))):
-        sample = tuple( n.asarray(i) for i in sample )
+        sample = tuple(n.asarray(i) for i in sample)
 
     if not weights is None:
         if isinstance(weights, tuple) and (all(map(lambda i: isinstance(i, list), weights))):
-            weights = tuple( n.asarray(i) for i in weights )
-        
+            weights = tuple(n.asarray(i) for i in weights)
+
 
     h = histogram.hist2d(bins, labels, title)
     h.fill(sample, weights)
Index: src/dashi/infobox.py
===================================================================
--- src/dashi/infobox.py	(revision 287)
+++ src/dashi/infobox.py	(working copy)
@@ -4,10 +4,10 @@
 import matplotlib.offsetbox
 
 class InfoBox(object):
-    def __init__(self, datadict, title = None, textprops = {"fontsize": 10, "family":"monospace"}, 
-                 titleprops= {"fontsize":10, "weight":"bold", "family":"monospace"},
-                 facecolor="w", edgecolor="k", alpha=1):
-        self.title    = title
+    def __init__(self, datadict, title = None, textprops = {"fontsize": 10, "family":"monospace"},
+                 titleprops = {"fontsize":10, "weight":"bold", "family":"monospace"},
+                 facecolor = "w", edgecolor = "k", alpha = 1):
+        self.title = title
         self.datadict = datadict
         self.textprops = dict(textprops)
         self.titleprops = dict(titleprops)
@@ -17,36 +17,36 @@
         self.box = None
 
 
-    def draw(self, axes=None, loc=2):
+    def draw(self, axes = None, loc = 2):
         if axes == None:
             axes = p.gca()
 
         if self.box != None and self.box in axes.artists:
             del axes.artists[ axes.artists.index(self.box) ]
-        
+
         #key_areas = [ mpl.offsetbox.TextArea(k, textprops=self.textprops) for k in self.datadict.keys() ]
         #val_areas = [ mpl.offsetbox.TextArea(self.datadict[k], textprops=self.textprops) for k in self.datadict.keys() ]
         key_areas = [ mpl.offsetbox.TextArea(k) for k in self.datadict.keys() ]
-        val_areas = [ mpl.offsetbox.TextArea(self.datadict[k]) for k in self.datadict.keys() ]
-        
-        key_vpack = mpl.offsetbox.VPacker(children=key_areas, align="left", pad=0, sep=0)
-        val_vpack = mpl.offsetbox.VPacker(children=val_areas, align="right", pad=0, sep=0)
-        hpack = mpl.offsetbox.HPacker(children=[key_vpack, val_vpack], align="top", pad=0,sep=4)
-        
+        val_areas = [ mpl.offsetbox.TextArea(v) for v in self.datadict.values() ]
+
+        key_vpack = mpl.offsetbox.VPacker(children = key_areas, align = "left", pad = 0, sep = 0)
+        val_vpack = mpl.offsetbox.VPacker(children = val_areas, align = "right", pad = 0, sep = 0)
+        hpack = mpl.offsetbox.HPacker(children = [key_vpack, val_vpack], align = "top", pad = 0, sep = 4)
+
         globchildren = []
         if self.title != None:
             #titlearea = mpl.offsetbox.TextArea(self.title, textprops=self.titleprops)
-            titlearea = mpl.offsetbox.TextArea(self.title)
+            titlearea = mpl.offsetbox.TextArea(self.title, textprops = {'weight':'bold'})
             globchildren.append(titlearea)
-        
+
         globchildren.append(hpack)
-        globvpack = mpl.offsetbox.VPacker(children=globchildren, align="center", pad=0, sep=1)
-        
-        self.box = mpl.offsetbox.AnchoredOffsetbox(loc=loc, child=globvpack)
+        globvpack = mpl.offsetbox.VPacker(children = globchildren, align = "center", pad = 0, sep = 1)
+
+        self.box = mpl.offsetbox.AnchoredOffsetbox(loc = loc, child = globvpack)
         self.box.patch.set_facecolor(self.facecolor)
         self.box.patch.set_edgecolor(self.edgecolor)
         self.box.patch.set_alpha(self.alpha)
-        axes.add_artist( self.box )
+        axes.add_artist(self.box)
 
         if p.isinteractive():
             p.gcf().canvas.draw()
Index: src/dashi/ticks.py
===================================================================
--- src/dashi/ticks.py	(revision 287)
+++ src/dashi/ticks.py	(working copy)
@@ -1,44 +1,46 @@
 
 from matplotlib.ticker import Locator
+from matplotlib.axis import XAxis
 import math
 import numpy
- 
+import pylab
+
 
 def coverage(dmin, dmax, lmin, lmax):
-    return 1. - 0.5 * ( (dmax-lmax)**2 + (dmin - lmin)**2 ) / (0.1 * (dmax - dmin) )**2
+    return 1. - 0.5 * ((dmax - lmax) ** 2 + (dmin - lmin) ** 2) / (0.1 * (dmax - dmin)) ** 2
 
 def coverage_max(dmin, dmax, span):
     drange = dmax - dmin
     if span > drange:
-        return 1. - (0.5*(span-drange))**2 / (0.1 * drange)**2
+        return 1. - (0.5 * (span - drange)) ** 2 / (0.1 * drange) ** 2
     else:
         return 1.
 
-def density(k,m,dmin,dmax,lmin,lmax):
-    r  = (k - 1.) / (lmax -lmin)
-    rt = (m - 1.) / (max(lmax,dmax) - min(lmin,dmin))
-    return 2. - max(r/rt, rt / r)
+def density(k, m, dmin, dmax, lmin, lmax):
+    r = (k - 1.) / (lmax - lmin)
+    rt = (m - 1.) / (max(lmax, dmax) - min(lmin, dmin))
+    return 2. - max(r / rt, rt / r)
 
-def density_max(k,m):
+def density_max(k, m):
     if k >= m:
         return 2. - (k - 1.0) / (m - 1.0)
     else:
         return 1.
-    
+
 
 def simplicity(q, Q, j, lmin, lmax, lstep):
     eps = 1e-10
     n = len(Q)
     i = Q.index(q) + 1
     v = 0
-    if ((lmin % lstep) < eps) or ( (((lstep-lmin) % lstep) < eps) and (lmin <= 0) and (lmax >= 0)):
+    if ((lmin % lstep) < eps) or ((((lstep - lmin) % lstep) < eps) and (lmin <= 0) and (lmax >= 0)):
         v = 1
     else:
         v = 0
 
     return (n - i) / (n - 1.0) + v - j
 
-def simplicity_max(q,Q,j):
+def simplicity_max(q, Q, j):
     n = len(Q)
     i = Q.index(q) + 1
     v = 1
@@ -47,16 +49,16 @@
 def legibility(lmin, lmax, lstep):
     return 1.
 
-def score(weights, simplicity, coverage,density, legibility):
-   return weights[0]*simplicity + weights[1]*coverage + weights[2]*density + weights[3]*legibility  
+def score(weights, simplicity, coverage, density, legibility):
+   return weights[0]*simplicity + weights[1]*coverage + weights[2]*density + weights[3]*legibility
 
-def wilk_ext(dmin, dmax, m, only_inside, 
-             Q=[1, 5, 2, 2.5, 4, 3], 
-             w=[0.2, 0.25, 0.5, 0.05]):
+def wilk_ext(dmin, dmax, m, only_inside,
+             Q = [1, 5, 2, 2.5, 4, 3],
+             w = [0.2, 0.25, 0.5, 0.05]):
 
     if (dmin >= dmax) or (m < 1):
         return (dmin, dmax, dmax - dmin, 1, 0, 2, 0)
-        
+
     n = float(len(Q))
     best_score = -1.0
     result = None
@@ -64,17 +66,17 @@
     j = 1.0
     while (j < numpy.inf):
         for q in map(float, Q):
-            sm = simplicity_max(q,Q,j)
+            sm = simplicity_max(q, Q, j)
 
-            if score(w,sm, 1,1,1) < best_score:
+            if score(w, sm, 1, 1, 1) < best_score:
                 j = numpy.inf
                 break
 
             k = 2.
             while k < numpy.inf:
-                dm = density_max(k,m) 
+                dm = density_max(k, m)
 
-                if score(w,sm,1,dm,1) < best_score:
+                if score(w, sm, 1, dm, 1) < best_score:
                     break
 
                 delta = (dmax - dmin) / (k + 1.) / j / q
@@ -82,35 +84,35 @@
 
                 while z < numpy.inf:
                     step = j * q * 10.**z
-                    cm = coverage_max(dmin, dmax, step * (k-1.))
-                    
-                    if score(w,sm,cm,dm,1) < best_score:
+                    cm = coverage_max(dmin, dmax, step * (k - 1.))
+
+                    if score(w, sm, cm, dm, 1) < best_score:
                         break
 
-                    min_start = math.floor(dmax/step)* j - (k-1.) * j
-                    max_start = math.ceil(dmin/step) * j
+                    min_start = math.floor(dmax / step) * j - (k - 1.) * j
+                    max_start = math.ceil(dmin / step) * j
 
                     if min_start > max_start:
                         z += 1
                         break
 
-                    for start in numpy.arange(min_start,max_start+1):
-                        lmin  = start * (step/j)
-                        lmax  = lmin + step * (k-1.0)
+                    for start in numpy.arange(min_start, max_start + 1):
+                        lmin = start * (step / j)
+                        lmax = lmin + step * (k - 1.0)
                         lstep = step
 
-                        s = simplicity(q,Q,j,lmin,lmax,lstep)
-                        c = coverage(dmin,dmax,lmin,lmax)
-                        d = density(k,m,dmin,dmax,lmin,lmax)
-                        l = legibility(lmin,lmax,lstep)
-                        scr = score(w,s,c,d,l)
+                        s = simplicity(q, Q, j, lmin, lmax, lstep)
+                        c = coverage(dmin, dmax, lmin, lmax)
+                        d = density(k, m, dmin, dmax, lmin, lmax)
+                        l = legibility(lmin, lmax, lstep)
+                        scr = score(w, s, c, d, l)
 
                         if (scr > best_score) and \
-                           ((only_inside <= 0) or ((lmin >= dmin) and (lmax <=dmax))) and \
+                           ((only_inside <= 0) or ((lmin >= dmin) and (lmax <= dmax))) and \
                            ((only_inside >= 0) or ((lmin <= dmin) and (lmax >= dmax))):
                             best_score = scr
                             #print "s: %5.2f c: %5.2f d: %5.2f l: %5.2f" % (s,c,d,l)
-                            result =  (lmin,lmax,lstep,j,q,k,scr)
+                            result = (lmin, lmax, lstep, j, q, k, scr)
 
                     z += 1
                 # end of z-while-loop    
@@ -118,7 +120,7 @@
             # end of k-while-loop
         j += 1
     # end of j-while-loop
-    return result 
+    return result
 
 class ExtendedWilkinsonTickLocator(Locator):
     """
@@ -137,6 +139,10 @@
                 >0 : label range must include data range
                 <0 : data range must be larger than label range 
 
+            *per_inch* : if per_inch=True then it specifies the number of ticks per
+                inch instead of a fixed number, so the actual number of
+                ticks depends on the size of the axis
+                
             *Q* : [ list of numbers ]
                 numbers that are considered as 'nice'. Ticks will be
                 multiples of these
@@ -147,21 +153,40 @@
             
                 see the reference for details
     """
-    def __init__(self, target_density, only_inside=0, 
-                 Q=[1, 5, 2, 2.5, 4, 3],
-                 w=[0.2, 0.25, 0.5, 0.05]):
+    def __init__(self, target_density, only_inside = 0, per_inch = False,
+                 Q = [1, 5, 2, 2.5, 4, 3],
+                 w = [0.2, 0.25, 0.5, 0.05]):
 
 
         self.target_density = target_density
         self.only_inside = only_inside
         self.Q = Q
         self.w = w
+        self.per_inch = per_inch
 
     def __call__(self):
         vmin, vmax = self.axis.get_view_interval()
-        if vmax<vmin:
+        if vmax < vmin:
             vmin, vmax = vmax, vmin
 
-        lmin,lmax,lstep,j,q,k,scr = wilk_ext(vmin, vmax, self.target_density, self.only_inside, self.Q, self.w)
+        # determine "physical" size of the axis and according # of ticks
+        if self.per_inch:
+            i = 0 if isinstance(self.axis, XAxis) else 1
+            axes = self.axis.get_axes()
+            pos = axes.get_position()
+            size = axes.get_figure().get_size_inches()
+            inches = size[i] * pos.bounds[i + 2]
+            nticks = self.target_density * inches
+        else:
+            nticks = self.target_density
+
+
+        lmin, lmax, lstep, j, q, k, scr = wilk_ext(vmin, vmax, nticks, self.only_inside, self.Q, self.w)
         #print "Ticking:" + ((7*"%f ") % (lmin,lmax,lstep,j,q,k,scr))
-        return numpy.arange(lmin,lmax+lstep,lstep)
+        return numpy.arange(lmin, lmax + lstep, lstep)
+
+def set_extended_locator(density = 1, per_inch = True, **kwargs):
+    'set the ExtendedWilkinsonTickLocator on current x- and y-axis'
+    ca = pylab.gca()
+    ca.xaxis.set_major_locator(ExtendedWilkinsonTickLocator(target_density = density, per_inch = per_inch, **kwargs))
+    ca.yaxis.set_major_locator(ExtendedWilkinsonTickLocator(target_density = density, per_inch = per_inch, **kwargs))
Index: src/dashi/histfuncs.py
===================================================================
--- src/dashi/histfuncs.py	(revision 287)
+++ src/dashi/histfuncs.py	(working copy)
@@ -21,62 +21,62 @@
     for i in xrange(histogram.ndim):
         if i != dim:
             tmp = tmp.sum(i)
-    assert abs(tmp.sum() - histogram.stats.weightsum < 1e-6)
+    assert abs(tmp.sum() - histogram.bincontent.sum() < 1e-6)
 
     return tmp
 
 def binned_mean_and_variance(bincontent, bincenters):
     wsum = bincontent.sum()
-    mean        = (bincontent * bincenters ).sum() / wsum
-    meansquared = (bincontent * bincenters**2 ).sum() / wsum
-    var = meansquared - mean**2 
+    mean = (bincontent * bincenters).sum() / wsum
+    meansquared = (bincontent * bincenters ** 2).sum() / wsum
+    var = meansquared - mean ** 2
 
     return (mean, var)
 
 
-def number_format(value, prec=5):
+def number_format(value, prec = 5):
     result = None
     factorexp = 0
     absvalue = abs(value)
     if value != 0 and (absvalue >= 1e6 or absvalue <= 1e-6):
         if value < 1:
-            factorexp = -divmod(-log10(absvalue),3)[0]*3
+            factorexp = -divmod(-log10(absvalue), 3)[0]*3
         else:
-            factorexp = divmod(log10(absvalue),3)[0]*3
-        
-        commonfactor = 10**factorexp
+            factorexp = divmod(log10(absvalue), 3)[0]*3
+
+        commonfactor = 10 ** factorexp
         value /= commonfactor
-    
-    if value<1:
+
+    if value < 1:
         # construct format string for that precision
         fmt = u"".join([u"%.", str(prec), u"f"])
-        result =  fmt % value
+        result = fmt % value
     else:
         fmt = u"".join([u"%.", str(prec), u"f"])
-        result =  fmt % value
+        result = fmt % value
 
     if factorexp != 0:
         result = u"%s\xb71e%d" % (result, factorexp)
 
     return unicode(result)
-    
+
 
 def number_error_format(value, error):
 
     result = None
     factorexp = 0
-    
+
     if error != 0 and (error >= 1e6 or error <= 1e-6):
         if error < 1:
-            factorexp = -divmod(-log10(error),3)[0]*3
+            factorexp = -divmod(-log10(error), 3)[0]*3
         else:
-            factorexp = divmod(log10(error),3)[0]*3
-        
-        commonfactor = 10**factorexp
+            factorexp = divmod(log10(error), 3)[0]*3
+
+        commonfactor = 10 ** factorexp
         value /= commonfactor
         error /= commonfactor
 
-    if error<1:
+    if error < 1:
         # digits needed for precision
         if error == 0:
             digits = 1
@@ -85,13 +85,13 @@
 
         # construct format string for that precision
         fmt = u"".join([u"%.", digits, u"f \u00B1 %.", digits, u"f"])
-        result =  fmt % (value,error)
+        result = fmt % (value, error)
     else:
         # digits needed for precision
         digits = str(int(abs(ceil(log10(error)))))
         # construct format string for that precision
         fmt = u"".join([u"%", digits, u".0f \u00B1 %", digits, u".0f"])
-        result =  fmt % (value,error)
+        result = fmt % (value, error)
 
     if factorexp != 0:
         result = u"(%s) 1e%d" % (result, factorexp)
@@ -101,11 +101,10 @@
 
 def generatebins_1d_tuple(bintuple):
     if isinstance(bintuple, tuple) and len(bintuple) == 3:
-        if not ( (bintuple[1] > bintuple[0]) and bintuple[2] > 0 ):
+        if not ((bintuple[1] > bintuple[0]) and bintuple[2] > 0):
             raise ValueError("problem with provided bins %s" % str(bintuple))
 
-        binwidth = float(bintuple[1] - bintuple[0]) / float(bintuple[2])
-        bins = n.linspace(bintuple[0]-binwidth, bintuple[1]+binwidth, bintuple[2]+3).round(12)
+        bins = n.linspace(bintuple[0], bintuple[1], bintuple[2] + 1).round(12)
         return bins
     else:
         raise ValueError("bintuple must be a tuple (leftedge, rightedgne, nbins)")
@@ -115,54 +114,49 @@
     sample = n.asarray(sample)
     if not len(sample.shape) == 1:
         raise ValueError("sample must be an array with shape (1,)")
-    finsample = sample[n.isfinite(sample)]
+
+    sample = sample[n.isfinite(sample)]
 
-    if len(finsample) == 0:
-        return n.linspace(0,1,nbins+1)
+    if len(sample) == 0:
+        return n.linspace(0, 1, nbins + 1)
 
-    mi,ma = finsample.min(), finsample.max()
+    mi, ma = sample.min(), sample.max()
     if mi == ma:
         mi -= 1
         ma += 1
-    tolerance = 0.005 * (ma - mi)
-    return n.linspace(mi-tolerance,ma+tolerance,nbins+1)
+    tolerance = 0.0001 * (ma - mi)
+    return n.linspace(mi - tolerance, ma + tolerance, nbins + 1)
 
 def generatebins_nd(ndim, sample, nbins):
     # TODO rework generatebins_nd to use generatebins_1d
-        
+
     # analyse given nbins
     if n.isscalar(nbins):
         nbins = (nbins,) * ndim
     elif isinstance(nbins, tuple):
         if not len(nbins) == ndim:
             raise ValueError("nbins is tuple with length != ndim")
-        if not all(map(n.isscalar, nbins)):
-            raise ValueError("nbins is tuple containing non scalars")
     else:
-        raise ValueError("nbins must be either a scalar or a tuple of lenght ndim.")
-    
+        raise ValueError("nbins must be either a scalar or a tuple of length ndim.")
+
     # analyse given sample
-    if isinstance(sample, tuple): 
+    if isinstance(sample, tuple):
         if not len(sample) == ndim:
             raise ValueError("sample is tuple with length != ndim")
         sample = n.vstack(sample).T
 
-    goodmask = n.ones(len(sample), dtype=bool)
-    for dim in xrange(ndim):
-        goodmask &= n.isfinite(sample[:,dim])
-    
     genbins = []
-    sample = sample[goodmask]
     for dim, nb in enumerate(nbins):
-        slice = sample[:,dim]
-        mi,ma = slice.min(), slice.max()
-        tolerance = 0.005 * (ma - mi)
-
-        genbins.append( n.linspace(mi-tolerance,ma+tolerance,nb+1) )
+        if isinstance(nb, tuple):
+            genbins.append(generatebins_1d_tuple(nb))
+        elif n.isscalar(nb):
+            genbins.append(generatebins_1d(sample[:, dim], nb))
+        else:
+            genbins.append(n.array(nb))
 
     return tuple(genbins)
 
-def h2profile(h2, dim=0):
+def h2profile(h2, dim = 0):
     """
         creates the profile plot of a 2d histogram
         h2  : 2d histogram
@@ -170,8 +164,8 @@
     """
 
     npoints = len(h2.bincenters[dim])
-    yval = n.zeros(npoints, dtype=float)
-    yerr = n.zeros(npoints, dtype=float)
+    yval = n.zeros(npoints, dtype = float)
+    yerr = n.zeros(npoints, dtype = float)
 
 
     otherdim = None
@@ -179,55 +173,55 @@
         otherdim = 1
         getLogger("dashi.h2profile").info("projecting along dimension 0")
         for i in xrange(npoints):
-            mean, var = binned_mean_and_variance(h2.bincontent[i,:], h2.bincenters[1])
+            mean, var = binned_mean_and_variance(h2.bincontent[i, :], h2.bincenters[1])
             yval[i] = mean
             yerr[i] = n.sqrt(var)
     elif dim == 1:
         otherdim = 0
         getLogger("dashi.h2profile").info("projecting along dimension 1")
         for i in xrange(npoints):
-            mean, var = binned_mean_and_variance(h2.bincontent[:,i], h2.bincenters[0])
+            mean, var = binned_mean_and_variance(h2.bincontent[:, i], h2.bincenters[0])
             yval[i] = mean
             yerr[i] = n.sqrt(var)
     else:
         raise ValueError("dim must be either 0 or 1")
 
     # remove nans and infs (empty bins)
-    mask = n.isfinite(yval) & n.isfinite(yerr) 
+    mask = n.isfinite(yval) & n.isfinite(yerr)
     prof = scatterpoints.points2d(len(mask[mask]))
 
 
-    prof.x    = h2.bincenters[dim][mask]
-    prof.xerr = h2._h_binwidths[dim][mask]/2. 
-    prof.y    = yval[mask]
+    prof.x = h2.bincenters[dim][mask]
+    prof.xerr = h2._h_binwidths[dim][mask] / 2.
+    prof.y = yval[mask]
     prof.yerr = yerr[mask]
     prof.labels[0] = h2.labels[dim]
     prof.labels[1] = h2.labels[otherdim]
 
     return prof
 
-def histratio(h1, h2, log=False, ylabel="ratio", mask_infs=True):
+def histratio(h1, h2, log = False, ylabel = "ratio", mask_infs = True):
     # linear case:
     # f = x/y with errors Dx, Dy
     # df = sqrt (DX / y ) **2 + (x/y**2* Dy)**2
     # logarithmic case:
     # f = log10(x/y) with errors Dx, Dy
     # df = sqrt( (Dx/x)**2 + (Dy/y)**2 ) / ln(10)
-    df_lin = lambda x,xerr,y,yerr:  n.sqrt( (xerr/y)**2 + (x*yerr/(y**2))**2)
-    df_log = lambda x,xerr,y,yerr: n.sqrt( (xerr/x)**2 + (yerr/y)**2 ) / n.log(10)
+    df_lin = lambda x, xerr, y, yerr:  n.sqrt((xerr / y) ** 2 + (x * yerr / (y ** 2)) ** 2)
+    df_log = lambda x, xerr, y, yerr: n.sqrt((xerr / x) ** 2 + (yerr / y) ** 2) / n.log(10)
 
 
     if not h1.is_compatible(h2):
         raise ValueError("histograms are not compatible")
 
     if log:
-        ratio = n.log10( h1.bincontent / h2.bincontent )
+        ratio = n.log10(h1.bincontent / h2.bincontent)
         errors = df_log(h1.bincontent, h1.binerror, h2.bincontent, h2.binerror)
     else:
         ratio = h1.bincontent / h2.bincontent
         errors = df_lin(h1.bincontent, h1.binerror, h2.bincontent, h2.binerror)
 
-    mask = n.ones(shape=h1.bincontent.shape, dtype=bool)
+    mask = n.ones(shape = h1.bincontent.shape, dtype = bool)
     if mask_infs:
         mask &= n.isfinite(ratio)
         mask &= n.isfinite(errors)
@@ -235,23 +229,23 @@
     prof = None
     if h1.ndim == 1:
         prof = scatterpoints.points2d(len(mask[mask]))
-        prof.x[:]    = h1.bincenters[mask]
+        prof.x[:] = h1.bincenters[mask]
         prof.xerr[:] = h1.binwidths[mask] / 2.
-        prof.y[:]    = ratio[mask]
+        prof.y[:] = ratio[mask]
         prof.yerr[:] = errors[mask]
         prof.labels[0] = h1.labels[0]
         prof.labels[1] = ylabel
         return prof
     elif h1.ndim == 2:
-        prof = scatterpoints.grid2d( (len(h1.bincenters[0]), len(h1.bincenters[1])) )
+        prof = scatterpoints.grid2d((len(h1.bincenters[0]), len(h1.bincenters[1])))
         imask = n.logical_not(mask)
         ratio[imask] = n.nan
         errors[imask] = n.nan
-        prof.x    = h1.bincenters[0] 
+        prof.x = h1.bincenters[0]
         prof.xerr = h1.xerr
-        prof.y    = h1.bincenters[1]
+        prof.y = h1.bincenters[1]
         prof.yerr = h1.yerr
-        prof.z    = ratio
+        prof.z = ratio
         prof.zerr = errors
 
         prof.labels[0] = h1.labels[0]
@@ -272,64 +266,64 @@
     num(bin boundaries) = num(bins) + 3
     """
 
-    if  ( len(self._h_binedges[0]) - 3 ) % bins_to_merge != 0:  
-        print "WARNING:",( len(self._h_binedges[0]) - 3 ) % bins_to_merge, "bin/bins at the end of the histogram are added to the overflow bin, because they don't fit to the new bin number!"
-    
-    if bins_to_merge >= ( len(self._h_binedges[0]) - 3 ):
+    if  (len(self._h_binedges[0]) - 3) % bins_to_merge != 0:
+        print "WARNING:", (len(self._h_binedges[0]) - 3) % bins_to_merge, "bin/bins at the end of the histogram are added to the overflow bin, because they don't fit to the new bin number!"
+
+    if bins_to_merge >= (len(self._h_binedges[0]) - 3):
         raise ValueError("The number of bins to merge in one new bins is larger than bin number in the histo!")
 
     # calculate new binedges:
-    new_binedges_bool = n.ones( len( self._h_binedges[0] ), dtype=n.bool) # filter the new bin_edges from _h_binedges      
-    new_bin_number = len( self._h_binedges[0] ) - 3 - ( len( self._h_binedges[0] ) - 3 ) % bins_to_merge # new bin number
+    new_binedges_bool = n.ones(len(self._h_binedges[0]), dtype = n.bool) # filter the new bin_edges from _h_binedges      
+    new_bin_number = len(self._h_binedges[0]) - 3 - (len(self._h_binedges[0]) - 3) % bins_to_merge # new bin number
 
-    for index in range( len(self._h_binedges[0]) ) :
-        if (  index > 0 and index < ( len(self._h_binedges[0]) - 1 )
-              and ( ( (index-1) % bins_to_merge != 0 ) or index > new_bin_number + 1 )  ) :      
-            
-            new_binedges_bool[index]=False
-    
+    for index in range(len(self._h_binedges[0])) :
+        if (index > 0 and index < (len(self._h_binedges[0]) - 1)
+              and (((index - 1) % bins_to_merge != 0) or index > new_bin_number + 1)) :
+
+            new_binedges_bool[index] = False
+
     new_binedges = self._h_binedges[0][new_binedges_bool]
 
     print "Bin edges of original histo:\n", self._h_binedges[0]
     print "Bin edges of the new histo :\n", new_binedges
 
     # calculate new bincontent and squaredweights:
-    new_bincontent =  [] 
+    new_bincontent = []
     new_squaredweights = []
     i, j, sum_content, sum_weight = 0, 0, 0, 0
-    while i < len(self._h_bincontent):           
+    while i < len(self._h_bincontent):
         sum_content = sum_content + self._h_bincontent[i]
         sum_weight = sum_weight + self._h_squaredweights[i]
-        if (j % bins_to_merge)==0 or i == len(self._h_bincontent) - 1:
+        if (j % bins_to_merge) == 0 or i == len(self._h_bincontent) - 1:
             new_bincontent.append(sum_content)
             new_squaredweights.append(sum_weight)
             sum_content, sum_weight, j = 0, 0, 0
-        i+=1
-        j+=1
+        i += 1
+        j += 1
 
-    new_bincontent = n.array( new_bincontent, dtype="float" )     
+    new_bincontent = n.array(new_bincontent, dtype = "float")
     print "Bin content of the original histo:\n", self._h_bincontent
     print "Bin content of the new histo     :\n", new_bincontent
-    if ( abs( self._h_bincontent.sum() - new_bincontent.sum() ) > 1e-8 ):
-        raise ValueError("Bin content of original and new histo (including overflow bins) is not the same!\n old = %10E new = %10E diff = %10E" % (self._h_bincontent.sum(), new_bincontent.sum(), self._h_bincontent.sum() - new_bincontent.sum() )  )
- 
+    if (abs(self._h_bincontent.sum() - new_bincontent.sum()) > 1e-8):
+        raise ValueError("Bin content of original and new histo (including overflow bins) is not the same!\n old = %10E new = %10E diff = %10E" % (self._h_bincontent.sum(), new_bincontent.sum(), self._h_bincontent.sum() - new_bincontent.sum()))
 
-    new_squaredweights = n.array( new_squaredweights, dtype="float" ) 
+
+    new_squaredweights = n.array(new_squaredweights, dtype = "float")
     print "Squared Weights of the original histo:\n", self._h_squaredweights
     print "Squared Weights of the original histo:\n", new_squaredweights
-    if ( abs( self._h_squaredweights.sum() - new_squaredweights.sum() ) > 1e-8 ):
-        raise ValueError("SquaredWeights of original and new histo (including overflow bins) is not the same!\n old = %10E new = %10E diff=%10E" % (self._h_squaredweights.sum(), new_squaredweights.sum(), self._h_squaredweights.sum() - new_squaredweights.sum() ) )
- 
-    
+    if (abs(self._h_squaredweights.sum() - new_squaredweights.sum()) > 1e-8):
+        raise ValueError("SquaredWeights of original and new histo (including overflow bins) is not the same!\n old = %10E new = %10E diff=%10E" % (self._h_squaredweights.sum(), new_squaredweights.sum(), self._h_squaredweights.sum() - new_squaredweights.sum()))
+
+
     # create new histogram with new properties:
-    new_histo = d.histogram.hist1d( new_binedges, label=self.labels, title=self.title )
-       
-    new_histo._h_bincontent[:] = new_bincontent[:]   
+    new_histo = d.histogram.hist1d(new_binedges, label = self.labels, title = self.title)
+
+    new_histo._h_bincontent[:] = new_bincontent[:]
     new_histo._h_squaredweights[:] = new_squaredweights[:]
-    
-    return new_histo 
 
-def kstest(h1a,h1b, skipemptybins=False):
+    return new_histo
+
+def kstest(h1a, h1b, skipemptybins = False):
     """
         perform a Kolmogorov-Smirnov-test on h1a and h1b.
         supported combinations are:
@@ -342,8 +336,8 @@
         p-value.
     """
     import scipy.stats
-    
-    
+
+
     if isinstance(h1a, d.histogram.hist1d) and isinstance(h1b, d.histogram.hist1d):
         if not h1a.is_compatible(h1b):
             raise ValueError("histograms must be compatible")
@@ -353,38 +347,38 @@
             m = h1a.bincontent > 0
             m &= h1b.bincontent > 0
         else:
-            m = n.ones(len(h1a.bincontent), dtype=bool)
+            m = n.ones(len(h1a.bincontent), dtype = bool)
+
+        ksdist = n.abs(h1a.bincontent[m].cumsum() / h1a.bincontent[m].sum() -
+                       h1b.bincontent[m].cumsum() / h1b.bincontent[m].sum()).max()
+        esum1 = h1a.bincontent[m].sum() ** 2 / n.power(h1a.binerror[m], 2).sum()
+        esum2 = h1b.bincontent[m].sum() ** 2 / n.power(h1b.binerror[m], 2).sum()
 
-        ksdist = n.abs(h1a.bincontent[m].cumsum()/h1a.bincontent[m].sum() - 
-                       h1b.bincontent[m].cumsum()/h1b.bincontent[m].sum()).max()
-        esum1 = h1a.bincontent[m].sum()**2 / n.power(h1a.binerror[m],2).sum() 
-        esum2 = h1b.bincontent[m].sum()**2 / n.power(h1b.binerror[m],2).sum() 
-            
-        z = ksdist * n.sqrt(esum1*esum2 / (esum1+esum2))
+        z = ksdist * n.sqrt(esum1 * esum2 / (esum1 + esum2))
         return ksdist, scipy.stats.ksprob(z)
-    elif ((isinstance(h1a, d.histogram.hist1d) and callable(h1b)) or 
+    elif ((isinstance(h1a, d.histogram.hist1d) and callable(h1b)) or
           (isinstance(h1a, d.histogram.hist1d) and isinstance(h1b, n.ndarray))):
-        
+
         m = None
         if skipemptybins:
             m = h1a.bincontent > 0
         else:
-            m = n.ones(len(h1a.bincontent), dtype=bool)
-        
+            m = n.ones(len(h1a.bincontent), dtype = bool)
+
         if callable(h1b):
             h1b = h1b(h1a.bincenters[m])
 
         if len(h1b) != len(h1a.bincontent[m]):
             raise ValueError("h1a and h1b have unequal lengths")
 
-        esum1 = h1a.bincontent[m].sum()**2 / n.power(h1a.binerror[m],2).sum()
-        ksdist = n.abs(h1a.bincontent[m].cumsum()/h1a.bincontent[m].sum() - h1b).max()
+        esum1 = h1a.bincontent[m].sum() ** 2 / n.power(h1a.binerror[m], 2).sum()
+        ksdist = n.abs(h1a.bincontent[m].cumsum() / h1a.bincontent[m].sum() - h1b).max()
         z = ksdist * n.sqrt(esum1)
         return ksdist, scipy.stats.ksprob(z)
     else:
         ValueError("unsupported combination of h1a and h1b. check docs")
 
-def weighted_histsum(histos, ylabel="weighted histsum"):
+def weighted_histsum(histos, ylabel = "weighted histsum"):
     for h in histos[1:]:
         if not histos[0].is_compatible(h):
             raise ValueError("histograms have to be compatible")
@@ -393,16 +387,16 @@
         raise ValueError("currently only a 1d implementation exists")
 
     nbins = len(histos[0]._h_bincontent)
-    bincontents = n.zeros((len(histos), nbins), dtype=float)
-    weights = n.zeros((len(histos), nbins), dtype=float)
+    bincontents = n.zeros((len(histos), nbins), dtype = float)
+    weights = n.zeros((len(histos), nbins), dtype = float)
 
-    for i,h in enumerate(histos):
-        bincontents[i,:] = h._h_bincontent
+    for i, h in enumerate(histos):
+        bincontents[i, :] = h._h_bincontent
         #weights[i,:] = 1. / n.power(h.binerror,2)
-        weights[i,:] = 1. / h._h_squaredweights
+        weights[i, :] = 1. / h._h_squaredweights
 
-    avg_bincontent = n.zeros(nbins, dtype=float)
-    avg_binerror   = n.zeros(nbins, dtype=float)
+    avg_bincontent = n.zeros(nbins, dtype = float)
+    avg_binerror = n.zeros(nbins, dtype = float)
 
 #    result = scatterpoints.points2d(nbins)
 #    result.x[:]    = histos[0].bincenters
@@ -422,13 +416,13 @@
 #    result.labels[1] = ylabel
 #    return result
 
-    result =  histos[0].empty_like()
+    result = histos[0].empty_like()
     for i in xrange(nbins):
-        m = n.isfinite(weights[:,i]) # select histograms with nonempty bins
+        m = n.isfinite(weights[:, i]) # select histograms with nonempty bins
         if len(m[m]) > 0:
-            sum1 = (bincontents[:,i][m] * weights[:,i][m]).sum()
-            sum2 = weights[:,i][m].sum()
-            
+            sum1 = (bincontents[:, i][m] * weights[:, i][m]).sum()
+            sum2 = weights[:, i][m].sum()
+
             result._h_bincontent[i] = sum1 / sum2
             result._h_squaredweights[i] = 1. / sum2
 
